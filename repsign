#! /bin/bash
#
#  repsign - 2018-05-06
#
#  Replaces "?" with "_" in all file names in the current directory.
#
#  Bernd Storck, https://www.facebook.com/BStLinux/
#
#  Version 1.2.0 with thanks to Dennis Tecker, who has checked my former code.

# Data for progams self description:
SCRIPTNAME="$(basename "$0")"
VERSION="1.2.0"

# Default values:
DIR="."
OLDSIGN="?"
NEWSIGN="_"

function hilfe() {
        if [ "${LANG::2}" = "de" ]; then

		echo -e "$SCRIPTNAME $VERSION \n"
		
		echo -e "AUFRUFVARIANTEN: \n"
		
		echo -e "\t1. $SCRIPTNAME \n" \
			"\t2. $SCRIPTNAME <ein_Zeichen> \n" \
			"\t3. $SCRIPTNAME <Zeichenfolge> <andere_Zeichenfolge> \n" \
			"\t4. $SCRIPTNAME <Pfad> <Zeichenfolge> <andere_Zeichenfolge> \n" \
			"\t5. $SCRIPTNAME -h|--help \n"

		echo -e "1. Das Programm ersetzt standardmäßig in den Namen aller Dateien des \n" \
			 "  aktuellen Verzeichnisses alle Fragezeichen durch einen Unterstrich. \n" \
		
		echo -e "2. Wird $SCRIPTNAME mit genau einem einzigem Parameter aufgerufen, mit der \n" \
			 "  Angabe eines Zeichens, dann ersetzt $SCRIPTNAME dieses Zeichen durch einen \n" \
			 "  Unterstrich. \n"
		
		echo -e "3. Mit zwei Parametern kann man bestimmen, welches Zeichen durch welches \n" \
			 "  andere Zeichen ersetzt wird. \n"
		
		echo -e "4. Bei drei Aufrufparametern bedeutet der erste das Verzeichnis, in dem \n" \
			 "  Dateinamen verändert werden sollen, der zweite, welches Zeichen \n" \
			 "  ersetzt werden soll, und der dritte, welches andere Zeichen stattdessen \n" \
			 "  eingefügt werden soll. \n"
	else
		echo -e "$SCRIPTNAME $VERSION \n"
		
		echo -e "CALLS: \n"
		
		echo -e "\t1. $SCRIPTNAME \n" \
			"\t2. $SCRIPTNAME <one_character> \n" \
			"\t3. $SCRIPTNAME <string> <another_string> \n" \
			"\t4. $SCRIPTNAME <path> <string> <another_string> \n" \
			"\t5. $SCRIPTNAME -h|--help \n" 
		
		echo -e "1. By default, the program replaces all wuestion marks with an under- \n" \
			 "  score in all file names in the current directory. \n"

		echo -e "2. If $SCRIPTNAME is called with exactly one parameter, one single \n" \
			 "  character, it will replace that character with an underscore. \n"
		
		echo -e "3. With two parameters you can decide, which string should be replaced \n" \
			 "  with which other text string. \n"
		
		echo -e "4. If you are using three parameters, then the first is the directory, \n" \
			 "  in which should be changed, the second says, which string should \n" \
		 	 "  be replaced, and the third says, which other string should be \n" \
			 "  inserted instead. \n"
	fi
	exit 0
}


function mask_signs() {
	REPLSIGN="${OLDSIGN//\?/\\\?}"
	REPLSIGN="${REPLSIGN//\*/\\\*}"	
}


function check_directory_existence() {
	if [ ! -d "$DIR" ]; then
		echo "Error: Could not find a directory \"$DIR\"." 2> /dev/stderr
		echo -e "\nPondering this point against my passionately fullfilled mission to rename files, I decided -- I decided not to rename files in a non-existing directory. I'm really sorry." 2> /dev/stderr
		exit 1
	fi
}


if [ $# -eq 3 ]; then
	DIR="$1"
	check_directory_existence
	OLDSIGN="$2"
	NEWSIGN="$3"
elif [ $# -eq 2 ]; then
	OLDSIGN="$1"
	NEWSIGN="$2"
elif [ -n "$1" ]; then
	if [ "$1" = "-h" -o "$1" = "--help" ]; then
		hilfe
	else
		OLDSIGN="$1"
	fi
else
        if [ "${LANG::2}" = "de" ]; then
		ASK="Sollen Fragezeichen in den Dateinamen durch einen Unterstrich ersetzt werden? [j|n]: "
		EXITMSG="Abbruch durch den Anwender."
	else
		ASK="Replace all question marks in file names with an underscore? [y|n]: "
		EXITMSG="Canceled by user."
	fi
	while : ;
	do	
		read -p "$ASK"
		case "$REPLY" in
			j|J|y|Y)
				break
				;;
			n|N)
				echo "$EXITMSG"
				sleep 1
				hilfe
				;;
		esac
	done
		
fi


( cd "$DIR"; for OLDNAME in *;  
do 
	[[ -f "$OLDNAME" ]] || continue  # If no normal file, then do not manipulate it.
        if grep -Fcqs "$OLDSIGN" <<< "$OLDNAME"; then
		if grep -cqs "[*?]" <<< "$OLDSIGN"; then
			mask_signs
		else
			REPLSIGN="$OLDSIGN"
		fi
                NEWNAME=${OLDNAME//$REPLSIGN/$NEWSIGN}
                if [ ${#NEWNAME} -lt 1 ]; then
                	echo "Error: Can not replace file name \"$OLDNAME\" by \"$NEWNAME\"." > /dev/stderr
                	continue  # File name of only one sign can not be replaced by nothing.
                fi
               	mv -iv "$OLDNAME" "$NEWNAME"
        fi
done )
